#![feature(proc_macro, specialization, plugin, extern_prelude, str_escape)]
#![plugin(rocket_codegen)]

extern crate serde;
#[macro_use] extern crate serde_derive;
#[macro_use] extern crate lazy_static;
extern crate serde_json;
extern crate glob;
extern crate rayon;
extern crate suffix;
extern crate indicatif;
extern crate rocket;
extern crate ndarray;
extern crate byteorder;
extern crate nom;
extern crate rand;
extern crate rustlearn;
extern crate rkm;
extern crate protobuf;
extern crate rocket_contrib;
extern crate flame;
extern crate fnv;

mod util;
mod text;
mod features;
mod datatypes; // autogenerated

use rocket::config::{Config, Environment};
use glob::glob;
use ndarray::Array;
use text::corpus::{Corpus, Map};
use features::{Features, Target};
use util::{ProgressIterator, BlockTimer};
use rocket_contrib::Json;
use std::collections::HashMap;

lazy_static! {
    static ref CORPUS: Corpus<text::index::LinearSearch>  = {
        let paths: Vec<_> = glob("/app/data/subs/orig/*").expect("Glob failed")
            .filter_map(|s| match s {
                Ok(p) => {
                    Some(p.to_str().expect("Path -> str failed").to_string())
                }
                Err(_) => None })
            .collect();
        Corpus::new(paths)
    };

    static ref FEATURES: Features = {
        Features::new()
    };
}

#[get("/lowercase")]
fn lowercase() -> Json<Vec<(String, f64, f64)>> {
    Json(CORPUS.lowercase_segments())
}

#[derive(Serialize, Deserialize)]
struct SubSearchInput {
    phrases: Vec<String>
}

#[post("/subsearch", format="application/json", data="<input>")]
fn sub_search(input: Json<SubSearchInput>) -> Json<Vec<Map<String, Vec<(f64, f64)>>>> {
    Json(input.phrases.iter().cloned().map(|phrase| CORPUS.find(phrase)).collect())
}


#[post("/subcount", format="application/json", data="<input>")]
fn sub_count(input: Json<SubSearchInput>) -> Json<Vec<u64>> {
    Json(input.phrases.iter().progress().cloned().map(|phrase| CORPUS.count(phrase)).collect())
}


#[post("/mutualinfo", format="application/json", data="<input>")]
fn mutual_info(input: Json<SubSearchInput>) -> Json<Vec<(String, f64)>> {
    let _timer = BlockTimer::new("mutualinfo");
    Json(CORPUS.all_mutual_info(input.phrases[0].clone()))
}

#[post("/getdoc", format="application/json", data="<input>")]
fn get_doc(input: Json<SubSearchInput>) -> Json<Vec<String>> {
    Json(CORPUS.get_doc(input.phrases[0].clone()))
}


#[get("/wordcounts")]
fn word_counts() -> Json<HashMap<String, usize>> {
    Json(CORPUS.word_counts())
}

#[get("/doclen")]
fn doc_len() -> Json<HashMap<String, usize>> {
    Json(CORPUS.doc_len())
}


#[get("/videos")]
fn videos() -> Json<Vec<String>> {
    Json(CORPUS.videos())
}

#[derive(Serialize, Deserialize)]
struct FindSegmentsInput {
    lexicon: Vec<(String, f64)>,
    threshold: f64,
    window_size: usize,
    merge_overlaps: bool,
    docs: Vec<String>,
    stride: usize
}

#[post("/findsegments", format="application/json", data="<input>")]
fn find_segments(input: Json<FindSegmentsInput>) -> Json<Vec<(String, (f32, f32), usize, f64, Map<String, usize>)>> {
    Json(
        CORPUS.find_segments(
            input.lexicon.clone(), input.stride, input.window_size, input.threshold, input.merge_overlaps,
            input.docs.iter().cloned().collect()
    ))
}


#[derive(Serialize, Deserialize)]
struct ComputeVectorsInput {
    vocabulary: Vec<String>,
    window_size: usize,
    stride: usize,
    docs: Vec<String>,
}

#[post("/computevectors", format="application/json", data="<input>")]
fn compute_vectors(input: Json<ComputeVectorsInput>) {
    CORPUS.compute_vectors(
        input.vocabulary.clone(), input.window_size, input.stride,
        input.docs.iter().cloned().collect()
    );
}

#[derive(Serialize, Deserialize)]
struct FaceSearchInput {
    exemplar: Vec<f32>,
    exemplars: Vec<Vec<f32>>,
    ids: Vec<u64>,
    k: isize,
    min_threshold: f32,
    max_threshold: f32,
    non_targets: Vec<u64>,
    non_target_penalty: f32
}

#[post("/facesearch", format="application/json", data="<input>")]
fn face_search(input: Json<FaceSearchInput>) -> Json<Vec<(u64,f32)>> {
    let target = if !input.ids.is_empty() {
        Target::Ids(input.ids.iter().map(|i| *i as features::Id).collect())
    } else if !input.exemplars.is_empty() {
        Target::Exemplars(input.exemplars.iter().map(|v| Array::from_vec(v.clone())).collect())
    } else {
        Target::Exemplar(Array::from_vec(input.exemplar.clone()))
    };
    let non_targets: Vec<features::Id> = input.non_targets.iter().map(|i| *i as features::Id).collect();

    Json(if input.k == -1 {
        FEATURES.tnn(&target, input.min_threshold, input.max_threshold, &non_targets, input.non_target_penalty)
    } else {
        FEATURES.knn(&target, input.k as usize, &non_targets, input.non_target_penalty)
    })
}

#[derive(Serialize, Deserialize)]
struct FaceSearchSVMInput {
    pos_ids: Vec<u64>,
    neg_ids: Vec<u64>,
    min_threshold: f32,
    max_threshold: f32,
    neg_samples: usize,
    pos_samples: usize,
}

#[post("/facesearch_svm", format="application/json", data="<input>")]
fn face_search_svm(input: Json<FaceSearchSVMInput>) -> Json<Vec<(u64,f32)>> {
    let pos_ids = input.pos_ids.iter().map(|i| *i as features::Id).collect();
    let neg_ids = input.neg_ids.iter().map(|i| *i as features::Id).collect();
    Json(FEATURES.svm(&pos_ids, &neg_ids, input.neg_samples, input.pos_samples,
                      input.min_threshold, input.max_threshold))
}

#[derive(Serialize, Deserialize)]
struct FaceKMeansInput {
    ids: Vec<features::Id>,
    k: usize,
}

#[post("/face_kmeans", format="application/json", data="<input>")]
fn face_kmeans(input: Json<FaceKMeansInput>) -> Json<Vec<(u64, usize)>> {
    Json(FEATURES.kmeans(&input.ids, input.k))
}

#[derive(Serialize, Deserialize)]
struct FaceFeaturesInput {
    ids: Vec<features::Id>,
}

#[post("/facefeatures", format="application/json", data="<input>")]
fn face_features(input: Json<FaceFeaturesInput>) -> Json<Vec<Vec<f32>>> {
    Json(FEATURES.features_for_id(&input.ids).into_iter().map(|v| v.to_vec()).collect())
}

fn main() {
    let config = Config::build(Environment::Development)
        .port(8111)
        .workers(1)
        .unwrap();
    rocket::custom(config, true).mount("/", routes![lowercase, sub_search, sub_count, mutual_info, find_segments, face_search, face_search_svm, face_features, face_kmeans, get_doc, word_counts, videos, doc_len, compute_vectors]).launch();
}
